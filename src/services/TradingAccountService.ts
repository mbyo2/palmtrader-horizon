import { supabase } from "@/integrations/supabase/client";

export type TradingAccountType = 'demo' | 'cent' | 'standard_stp' | 'raw_ecn' | 'pro_ecn' | 'islamic';

export interface AccountTypeConfig {
  id: string;
  account_type: TradingAccountType;
  display_name: string;
  description: string;
  min_deposit: number;
  max_leverage: number;
  commission_per_lot: number;
  min_spread: number;
  execution_type: string;
  is_swap_free: boolean;
  features: string[];
  requirements: string;
  is_available: boolean;
}

export interface TradingAccount {
  id: string;
  user_id: string;
  account_number: string;
  account_type: TradingAccountType;
  account_name: string | null;
  currency: string;
  balance: number;
  available_balance: number;
  reserved_balance: number;
  leverage: number;
  max_leverage: number;
  min_deposit: number;
  commission_per_lot: number;
  spread_type: string;
  min_spread: number;
  margin_call_level: number;
  stop_out_level: number;
  is_active: boolean;
  is_verified: boolean;
  trading_disabled: boolean;
  trading_disabled_reason: string | null;
  sec_zambia_compliant: boolean;
  created_at: string;
  updated_at: string;
}

export class TradingAccountService {
  // Get all account type configurations
  static async getAccountTypeConfigs(): Promise<AccountTypeConfig[]> {
    try {
      const { data, error } = await supabase
        .from('account_type_configs')
        .select('*')
        .eq('is_available', true)
        .order('min_deposit', { ascending: true });

      if (error) throw error;
      return (data || []).map(config => ({
        ...config,
        features: Array.isArray(config.features) 
          ? (config.features as string[]) 
          : JSON.parse(String(config.features || '[]'))
      })) as AccountTypeConfig[];
    } catch (error) {
      console.error("Error fetching account type configs:", error);
      return [];
    }
  }

  // Get user's trading accounts
  static async getUserAccounts(): Promise<TradingAccount[]> {
    try {
      const { data: user } = await supabase.auth.getUser();
      if (!user.user) throw new Error("Not authenticated");

      const { data, error } = await supabase
        .from('trading_accounts')
        .select('*')
        .eq('user_id', user.user.id)
        .order('created_at', { ascending: false });

      if (error) throw error;
      return (data || []) as TradingAccount[];
    } catch (error) {
      console.error("Error fetching user accounts:", error);
      return [];
    }
  }

  // Create a new trading account
  static async createAccount(
    accountType: TradingAccountType,
    currency: string = 'USD',
    accountName?: string,
    initialDeposit: number = 0
  ): Promise<TradingAccount | null> {
    try {
      const { data: user } = await supabase.auth.getUser();
      if (!user.user) throw new Error("Not authenticated");

      // Get account type config for defaults
      const { data: config } = await supabase
        .from('account_type_configs')
        .select('*')
        .eq('account_type', accountType)
        .single();

      if (!config) throw new Error("Invalid account type");

      // Check if user meets minimum deposit requirement (except for demo)
      if (accountType !== 'demo' && initialDeposit < config.min_deposit) {
        throw new Error(`Minimum deposit for ${config.display_name} is $${config.min_deposit}`);
      }

      const balance = accountType === 'demo' ? 100000 : initialDeposit;

      const { data, error } = await supabase
        .from('trading_accounts')
        .insert({
          user_id: user.user.id,
          account_type: accountType,
          account_name: accountName || config.display_name,
          currency,
          balance,
          available_balance: balance,
          leverage: 100,
          max_leverage: config.max_leverage,
          min_deposit: config.min_deposit,
          commission_per_lot: config.commission_per_lot,
          min_spread: config.min_spread,
          is_verified: accountType === 'demo',
          account_number: '' // Will be auto-generated by trigger
        })
        .select()
        .single();

      if (error) throw error;
      return data as TradingAccount;
    } catch (error) {
      console.error("Error creating trading account:", error);
      throw error;
    }
  }

  // Get single account by ID
  static async getAccount(accountId: string): Promise<TradingAccount | null> {
    try {
      const { data, error } = await supabase
        .from('trading_accounts')
        .select('*')
        .eq('id', accountId)
        .single();

      if (error) throw error;
      return data as TradingAccount;
    } catch (error) {
      console.error("Error fetching account:", error);
      return null;
    }
  }

  // Update account settings
  static async updateAccount(
    accountId: string,
    updates: {
      account_name?: string;
      leverage?: number;
    }
  ): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('trading_accounts')
        .update(updates)
        .eq('id', accountId);

      if (error) throw error;
      return true;
    } catch (error) {
      console.error("Error updating account:", error);
      return false;
    }
  }

  // Deposit funds to account
  static async deposit(accountId: string, amount: number): Promise<boolean> {
    try {
      const account = await this.getAccount(accountId);
      if (!account) throw new Error("Account not found");
      if (account.account_type === 'demo') throw new Error("Cannot deposit to demo account");

      const { error } = await supabase
        .from('trading_accounts')
        .update({
          balance: account.balance + amount,
          available_balance: account.available_balance + amount
        })
        .eq('id', accountId);

      if (error) throw error;
      return true;
    } catch (error) {
      console.error("Error depositing funds:", error);
      return false;
    }
  }

  // Withdraw funds from account
  static async withdraw(accountId: string, amount: number): Promise<boolean> {
    try {
      const account = await this.getAccount(accountId);
      if (!account) throw new Error("Account not found");
      if (account.account_type === 'demo') throw new Error("Cannot withdraw from demo account");
      if (amount > account.available_balance) throw new Error("Insufficient funds");

      const { error } = await supabase
        .from('trading_accounts')
        .update({
          balance: account.balance - amount,
          available_balance: account.available_balance - amount
        })
        .eq('id', accountId);

      if (error) throw error;
      return true;
    } catch (error) {
      console.error("Error withdrawing funds:", error);
      return false;
    }
  }

  // Get account type display info
  static getAccountTypeInfo(type: TradingAccountType): { color: string; badge: string } {
    const info: Record<TradingAccountType, { color: string; badge: string }> = {
      demo: { color: 'bg-gray-500', badge: 'Demo' },
      cent: { color: 'bg-green-500', badge: 'Cent' },
      standard_stp: { color: 'bg-blue-500', badge: 'Standard' },
      raw_ecn: { color: 'bg-purple-500', badge: 'Raw ECN' },
      pro_ecn: { color: 'bg-amber-500', badge: 'Pro ECN' },
      islamic: { color: 'bg-emerald-500', badge: 'Islamic' }
    };
    return info[type] || info.demo;
  }
}
